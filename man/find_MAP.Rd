% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_MAP.R
\name{find_MAP}
\alias{find_MAP}
\title{Find the Maximum A Posteriori Estimation}
\usage{
find_MAP(
  g,
  max_iter = NA,
  return_probabilities = FALSE,
  show_progress_bar = TRUE,
  optimizer = NA
)
}
\arguments{
\item{g}{object of \code{gips} class}

\item{max_iter}{number of iterations for an algorithm to perform. At least 2. For \code{optimizer=="MH"} has to be finite; for \code{optimizer=="HC"}, can be infinite; for \code{optimizer=="BF"} it is not used.}

\item{return_probabilities}{boolean. TRUE can only be provided for \code{optimizer=="MH"}. Whether to use Metropolis-Hastings results to calculate posterior probabilities.}

\item{show_progress_bar}{boolean. Indicate weather or not show the progress bar.}

\item{optimizer}{the optimizer for the search of the maximum posteriori. Currently the "MH" - Metropolis-Hastings algorithm, or "HC" - Hill Climbing algorithm, or "BF" - brute force algorithm, or "continue" to continue the optimization performed on the \code{g} object (see Examples). By default, NA that is changed into "MH" when \code{g} is unoptimized and "continue", when \code{g} is optimized. See "Possible algorithms to use as optimizers" section below.}
}
\value{
object of class gips
}
\description{
Use one of optimization algorithms to find the permutation that maximizes a posteriori based on observed data. Not all optimization algorithms will always find the MAP, but they try to find a big value. TODO(More information can be found in 'Details'.)
}
\section{Possible algorithms to use as optimizers}{

\itemize{
\item \code{"Metropolis_Hastings"}, \code{"MH"} - to use Metropolis-Hastings algorithm \href{https://en.wikipedia.org/wiki/Metropolis–Hastings_algorithm}{see Wikipedia}
\item \code{"hill_climbing"}, \code{"HC"} - to use Metropolis-Hastings algorithm \href{https://en.wikipedia.org/wiki/Metropolis–Hastings_algorithm}{see Wikipedia}
\item \code{"brute_force"}, \code{"BF"}, \code{"full"} - to use Brute Force algorithm that checks the whole permutation space of a given size. This algorithm will definitely find the Maximum A Posteriori Estimation, but is very computationally expensive for bigger space.
}
}

\examples{
require("MASS") # for mvrnorm()

perm_size <- 6
mu <- numeric(perm_size)
sigma_matrix <- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.4, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.4, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6, 0.4,
    0.4, 0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.4, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.4, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
) # sigma is a matrix invariant under permutation (1,2,3,4,5,6)
number_of_observations <- 13
Z <- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S <- (t(Z) \%*\% Z) / number_of_observations # the theoretical mean is 0

g <- gips(S, number_of_observations)

g_map <- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "MH")
g_map

g_map2 <- find_MAP(g_map, max_iter = 10, show_progress_bar = FALSE, optimizer = "continue")

if (require("graphics")) {
  plot(g_map2, type = "both", logarithmic_x = TRUE)
}

g_map_BF <- find_MAP(g, show_progress_bar = FALSE, optimizer = "BF")
summary(g_map_BF)
}
\seealso{
\code{\link[=gips]{gips()}}, \code{\link[=gips_perm]{gips_perm()}}, \code{\link[=project_matrix]{project_matrix()}}
}
