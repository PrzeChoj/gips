% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gips_class.R
\name{gips}
\alias{gips}
\alias{new_gips}
\alias{validate_gips}
\title{Constructor of the \code{gips} class.}
\usage{
gips(S, number_of_observations, delta = 3, D_matrix = NULL, perm = "")

new_gips(
  list_of_gips_perm,
  S,
  number_of_observations,
  delta,
  D_matrix,
  optimization_info
)

validate_gips(g)
}
\arguments{
\item{S}{A matrix, estimated covariance matrix. When Z is observed data: \code{S = (t(Z) \%*\% Z) / number_of_observations}, if one know the theoretical mean is 0; # TODO(What if one have to estimate the theoretical mean with the empirical mean).}

\item{number_of_observations}{A number of data points that \code{S} is based on.}

\item{delta}{A hyper-parameter of a Bayesian model. Has to be bigger than 2.}

\item{D_matrix}{A hyper-parameter of a Bayesian model. Square matrix of the same size as \code{S}. When NULL, the identity matrix is taken.}

\item{perm}{An optional permutation to be the base for \code{gips} object. Can be of the class \code{gips_perm} or \code{permutation} or anything the function \code{permutations::permutation()} can take.}

\item{list_of_gips_perm}{A list with a single element of class \code{gips_perm}. The base object for the \code{gips} class.}

\item{optimization_info}{NULL or the list with information about the optimization process.}

\item{g}{Element to be checked if it is proper element of class \code{gips}.}
}
\value{
Object of class gips.
}
\description{
Create the \code{gips} object.
This object will consists data and all other information needed to find the invariant group.
The optimization itself will not be performed. To do it, one have to call the \code{\link[gips]{find_MAP}} function. See examples below.
}
\section{Functions}{
\itemize{
\item \code{new_gips()}: Constructor

Only intended for low-level use.

\item \code{validate_gips()}: Validator

Only intended for low-level use.

}}
\examples{
require("MASS") # for mvrnorm()

perm_size <- 6
mu <- numeric(perm_size)
# sigma is a matrix invariant under permutation (1,2,3,4,5,6)
sigma_matrix <- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.4, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.4, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6, 0.4,
    0.4, 0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.4, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.4, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
)
number_of_observations <- 13
Z <- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S <- (t(Z) \%*\% Z) / number_of_observations # the theoretical mean is 0

g <- gips(S, number_of_observations)

g_map <- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "MH")
g_map

summary(g_map)

if (require("graphics")) {
  plot(g_map, type = "both", logarithmic_x = TRUE)
}
}
\seealso{
\code{\link[=find_MAP]{find_MAP()}}, \code{\link[=gips_perm]{gips_perm()}}
}
