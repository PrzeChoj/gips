% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gips_class.R
\name{gips}
\alias{gips}
\alias{new_gips}
\alias{validate_gips}
\title{The constructor of a \code{gips} class.}
\usage{
gips(S, number_of_observations, delta = 3, D_matrix = NULL, perm = "")

new_gips(
  list_of_gips_perm,
  S,
  number_of_observations,
  delta,
  D_matrix,
  optimization_info
)

validate_gips(g)
}
\arguments{
\item{S}{A matrix; estimated covariance matrix.
When Z is the observed data:
\enumerate{
\item if one know the theoretical mean is 0, use
\code{S = (t(Z) \%*\% Z) / number_of_observations};
\item if one does not know the theoretical mean and has to
estimate it with the observed mean, use \code{S = cov(Z)}
and set the \code{number_of_observations} parameter to 1 less than
the real number of observations.
TODO(Make the parameter and change the line to: "and set the parameter \code{mean_estimated} to TRUE").
}}

\item{number_of_observations}{A number of data points
that \code{S} is based on.}

\item{delta}{A hyper-parameter of a Bayesian model.
Has to be bigger than 2.}

\item{D_matrix}{A hyper-parameter of a Bayesian model.
Square matrix of the same size as \code{S}.
When NULL, the identity matrix is taken.}

\item{perm}{An optional permutation to be the base for the \code{gips} object.
Can be of a \code{gips_perm} or a \code{permutation} class, or anything
the function \code{\link[permutations:permutation]{permutations::permutation()}} can handle.}

\item{list_of_gips_perm}{A list with a single element of
a \code{gips_perm} class. The base object for the \code{gips} object.}

\item{optimization_info}{NULL or the list with
information about the optimization process.}

\item{g}{Element to be checked if it is proper element of a \code{gips} class.}
}
\value{
\code{gips()} returns an object of
a \code{gips} class after the safety checks.

\code{new_gips()} returns an object of
a \code{gips} class without the safety checks.

\code{validate_gips()} returns its argument unchanged.
If the argument is not a correct element of a \code{gips} class,
it produces an error.
}
\description{
Create a \code{gips} object.
This object will consist of data and all other information needed to find
the most likely invariant permutation. The optimization itself
will not be performed. One must call the \code{\link[=find_MAP]{find_MAP()}}
function to do it. See examples below.
}
\section{Functions}{
\itemize{
\item \code{new_gips()}: Constructor. Only intended for low-level use.

\item \code{validate_gips()}: Validator. Only intended for low-level use.

}}
\section{Methods for a \code{gips} class}{

\itemize{
\item \code{\link[=summary.gips]{summary.gips()}}
\item \code{\link[=plot.gips]{plot.gips()}}
\item \code{\link[=print.gips]{print.gips()}}
}
}

\examples{
require("MASS") # for mvrnorm()

perm_size <- 6
mu <- numeric(perm_size)
sigma_matrix <- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.4, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.4, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6, 0.4,
    0.4, 0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.4, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.4, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6)
number_of_observations <- 13
Z <- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S <- (t(Z) \%*\% Z) / number_of_observations # the theoretical mean is 0

g <- gips(S, number_of_observations)

g_map <- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "MH")
g_map

summary(g_map)

if (require("graphics")) {
  plot(g_map, type = "both", logarithmic_x = TRUE)
}
}
\seealso{
\itemize{
\item \code{\link[=find_MAP]{find_MAP()}} - The function that finds
the Maximum A Posteriori (MAP) Estimator
for a given \code{gips} object.
\item \code{\link[=gips_perm]{gips_perm()}} - The constructor of a \code{gips_perm} class.
The \code{gips_perm} object is used as the base object for
the \code{gips} object. To be more precise, the \code{gips} object has
a one-element list of a \code{gips_perm} object as the base object.
}
}
